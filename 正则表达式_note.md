## 正则表达式入门

   * 基础入门

     关于正则表达式匹配中由**字符匹配符号**和**次数匹配符号**两种。

     字符匹配符号为： '.'  '[]'  '^'

     次数匹配符号为 ：'+'  '*'  '?'  ’{}‘

     如需要查找A字符出现B次的字符串，那么就需要**字符匹配符号**和**次数匹配符号**组合。

     * '  . '  匹配任意一个字符

     * ' + '  匹配1或多次出现的字符

     * ’  ? '  匹配0-1次出现的字符

     * ’  * ‘  匹配0次或者多次出现的字符

       ```python
       * [Pp]ython   匹配python和Python
       * [a-z]	      匹配a-z中所有数字
       * .ar		  匹配所有xar的字符,其中x代表任意一个字符
       * wo?d		  匹配word和wod
       * .*		  匹配所有字符
       ```

       ---

       **. 代表匹配任意一个字符，* 代表匹配0或者多次出现的字符。两者集合起来就是0或者多次出现的任意字符，也就是字符串全集。因此 .* 代表全匹配。**

       ---

     * ' [] ' 用来定义你希望匹配的字符

       ```python
       * [0-9]	       匹配0-9中所有数字
       * [^0-9]       匹配所有非数字
       * [a-z]	 	   匹配a-z中所有数字
       * [\d]	  	   匹配所有数字
       * [\w]	  	   匹配所有数字 字母 以及下划线
       * [\s]	 	   匹配空格
       * [\D]	  	   匹配所有非数字
       * [\W]	  	   匹配所有的非字符
       * [\S]	 	   匹配所有非空格
       * [\-]	       匹配单个斜杠
       ```

       ---

       **注意在上述 表达式中，'\d'代表所有数字  ’\s‘代表空格 ’  '\w'代表数字、字母和下划线**。

       **由于’ - ‘符号具有二义性，前面必须加上\来避免歧义**。

       ---

     - ^ 代表匹配以xxx开头的字符   $代表匹配以xxx为结尾的字符。

       ```python
       * ^python	    匹配开头是Python的所有字符 ^放在单词前
       * OS$			匹配以OS为结尾的所有字符 $放在单词后
       ```

       ---

       **需要注意的是，^既可以放在括号内，表示非，也可以放在括号外，表示以xxx为开头**

       ---

       

     -  \d{n} 匹配连续n个数字	

       ```python
       * \d{8,9}		匹配连续8或者9个数字 优先匹配连续9个数字
       * \d{8,9}?	    匹配连续8或者9个数字 优先匹配连续8个数字
       * \d{3,}		匹配3-正无穷个数字
       * \d{3,9}		匹配连续3-9个数字 优先匹配连续9个数字
       ```

   * 贪婪匹配和简单匹配

           * 贪婪匹配： 找符合正则表达式的最长可能部分返回（默认为贪婪匹配）

           * 简单匹配： 找符合正则表达式最小可能部分返回

                ```python
                源串：titanic
                t[a-z]*i		贪婪匹配 可以同时匹配ti和titani默认返回titani
                t[a-z]*?i	    懒惰匹配 返回ti
                源串：<h1>Winter is comming</h1>
                <.*?>		    懒惰匹配 匹配<h1> 而不是<h1>Winter is comming</h1>
                ```

   * 逻辑运算符

        ​	如果需要匹配的是多个正则表达式的并集，可将这些匹配结果用|进行合并

        

        | 实例          | 描述                                |
        | ------------- | ----------------------------------- |
        | `[Pp]ython`   | 匹配 “Python” 或 “python”。         |
        | `rub[ye]`     | 匹配 “ruby” 或 “rube”。             |
        | `[abcdef]`    | 匹配中括号内的任意一个字母。        |
        | `[0-9]`       | 匹配任何数字。类似于 [0123456789]。 |
        | `[a-z]`       | 匹配任何小写字母。                  |
        | `[A-Z]`       | 匹配任何大写字母。                  |
        | `[a-zA-Z0-9]` | 匹配任何字母及数字。                |
        | `[^au]`       | 除了au字母以外的所有字符。          |
        | `[^0-9]`      | 匹配除了数字外的字符。              |

        | 实例 | 描述                                                         |
        | ---- | ------------------------------------------------------------ |
        | `.`  | 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。 |
        | `?`  | 匹配一个字符零次或一次，另一个作用是非贪婪模式               |
        | `+`  | 匹配1次或多次                                                |
        | `*`  | 匹配0次或多次                                                |
        | `\b` | 匹配一个长度为`0`的子串                                      |
        | `\d` | 匹配一个数字字符。等价于 [0-9]。                             |
        | `\D` | 匹配一个非数字字符。等价于 [^0-9]。                          |
        | `\s` | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
        | `\S` | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
        | `\w` | 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。         |
        | `\W` | 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]‘。                 |
        | `\b` | 匹配一个长度为`0`的子串                                      |

## 正则表达式进阶

* 捕获组

  在匹配的过程中用()来提取相关的数据

  ```python
  提取0731xxx2942444的数字部分     (\d{4})-(\d{7})
  提取2019-5013-08、2019 5013 08、2019501308中的2019 5013 08
  (\d{4})[\-\s]?(\d{4})[\-\s]?(\d{2})
  ```

  有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。

  这个时候就可以使用非捕获组`(?:表达式)`，从而**不捕获数据**，还能使用分组的功能。

  例如想要匹配**两个字母组成的单词**或者**四个字母组成的单词**就可以使用**非捕获分组**：

  ```python
  \b(?:\w{2}|\w{4})\b
  ```

* 分组的回溯引用

  正则表达式还提供了一种引用之前匹配分组的机制，有些时候，我们或许会寻找到一个子匹配，该匹配接下来会再次出现。

  例如，要匹配一段 HTML 代码，比如：`0123<font>提示</font>abcd`，可能会编写出这样一段正则表达式：

  ```python
  <\w+>.*?</\w+>
  ```

  这确实可以匹配，不过可能还有另一种情况，如果数据改成这样：`<font>提示</bar>`

  在这里`font` 和 `bar` 明显不是一对正确的标签，但是我们编写的正则表达式还是将它们给匹配了，所以这个结果是错误的。

  我们想让后面分组的正则也匹配`font`，但是现在所有形式的都会匹配。

  那如果想让后面分组的正则和第一个分组的正则匹配同样的数据该如何做呢？

  可以使用**分组的回溯引用**，使用`\N`可以引用编号为`N`的分组，因此上述例子的代码我们可以改为：

  ```python
  <(\w+)>.*?</\1>	#此处\1就代表了前面括号中提取的内容
  ```

  更简单的例子有

  ```python
  匹配abba这种类型的单词	(\w)(\w)\2\1
  (\d+)\s\1\s\1	等价于  \d+\s\d+\s\d+
  ```

  

## 练习网址

​		正则在线测试工具		http://regexr-cn.com/

​		正则相关练习    http://codejiaonang.com/
